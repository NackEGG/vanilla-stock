
-- 특정 기간 이후 STOCK_RECORDS 조회 
CREATE OR REPLACE PROCEDURE USP_GET_LIST_STOCK_RECORDS(
	PI_STOCK_CODE IN STOCK_RECORDS.STOCK_CODE%TYPE,
	PI_T_DATE IN STOCK_RECORDS.T_DATE%TYPE,
	PO_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT *
		FROM STOCK_RECORDS
		WHERE STOCK_CODE = PI_STOCK_CODE
			AND T_DATE > PI_T_DATE
		ORDER BY T_DATE;
END;
/

-- 회사명이나 회사코드로 Company 하나 선택해서 조회
CREATE OR REPLACE PROCEDURE USP_GET_COMPANY(
	PI_KEYWORD IN VARCHAR,
	PO_STOCK_CODE OUT COMPANY.STOCK_CODE%TYPE,
	PO_COMPANY OUT COMPANY.COMPANY%TYPE,
	PO_INDUSTRY_NO OUT COMPANY.INDUSTRY_NO%TYPE,
	PO_STOCK_LISTED OUT COMPANY.STOCK_LISTED%TYPE,
	PO_CAPITAL OUT COMPANY.CAPITAL%TYPE,
	PO_FACEVALUE OUT COMPANY.FACEVALUE%TYPE,
	PO_CURRENCY OUT COMPANY.CURRENCY%TYPE,
	PO_TEL OUT COMPANY.TEL%TYPE,
	PO_ADDRESS OUT COMPANY.ADDRESS%TYPE,
	PO_REGDATE OUT COMPANY.REGDATE%TYPE
	)
IS
BEGIN
	SELECT *
	INTO PO_STOCK_CODE, PO_COMPANY, PO_INDUSTRY_NO, PO_STOCK_LISTED, PO_CAPITAL,
		PO_FACEVALUE, PO_CURRENCY, PO_TEL, PO_ADDRESS, PO_REGDATE
	FROM COMPANY
	WHERE STOCK_CODE = PI_KEYWORD
		OR COMPANY = PI_KEYWORD;
END;
/

-- 회사명이나 회사코드를 검색해서 해당 키워드가 들어가는 Company List
CREATE OR REPLACE PROCEDURE USP_SEARCH_LIST_COMPANY(
	PI_KEYWORD IN VARCHAR,
	PO_CURSOR OUT SYS_REFCURSOR)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT *
		FROM COMPANY
		WHERE STOCK_CODE LIKE '%'||PI_KEYWORD||'%'
			OR COMPANY LIKE '%'||PI_KEYWORD||'%'
		ORDER BY COMPANY;
END;
/

-- 회사코드로 해당 회사의 Industry 정보 조회
CREATE OR REPLACE PROCEDURE USP_GET_INDUSTRY(
	PI_STOCK_CODE IN COMPANY.STOCK_CODE%TYPE,
	PO_NO OUT INDUSTRY.NO%TYPE,
	PO_NAME OUT INDUSTRY.NAME%TYPE,
	PO_REGDATE OUT INDUSTRY.REGDATE%TYPE)
AS
BEGIN
	SELECT NO, NAME, INDUSTRY.REGDATE
	INTO PO_NO, PO_NAME, PO_REGDATE
	FROM INDUSTRY JOIN COMPANY 
	ON INDUSTRY.NO = COMPANY.INDUSTRY_NO
	WHERE COMPANY.STOCK_CODE = PI_STOCK_CODE;
END;
/

-- 게시판 Insert문
CREATE OR REPLACE PROCEDURE USP_ADD_ARTICLE(
	PI_TITLE IN ARTICLE.TITLE%TYPE,
	PI_COMPANY_NAME IN COMPANY.COMPANY%TYPE,
	PI_MEMBER_NO IN ARTICLE.MEMBER_NO%TYPE
)
AS
BEGIN
	INSERT INTO ARTICLE
	VALUES(ARTICLE_SEQ.NEXTVAL, PI_TITLE, 
			(SELECT STOCK_CODE FROM COMPANY WHERE COMPANY = PI_COMPANY_NAME), 
			PI_MEMBER_NO, SYSDATE);
END;
/

-- 게시판 조회 문
CREATE OR REPLACE PROCEDURE USP_GET_ARTICLE(
	PIO_ARTICLE_NO IN OUT ARTICLE.NO%TYPE,
	PO_TITLE OUT ARTICLE.TITLE%TYPE,
	PO_STOCK_CODE OUT ARTICLE.STOCK_CODE%TYPE,
	PO_MEMBER_NO OUT ARTICLE.MEMBER_NO%TYPE,
	PO_REGDATE OUT ARTICLE.REGDATE%TYPE)
AS
BEGIN
	SELECT *
	INTO PIO_ARTICLE_NO, PO_TITLE, PO_STOCK_CODE, PO_MEMBER_NO, PO_REGDATE
	FROM ARTICLE
	WHERE NO = PIO_ARTICLE_NO;
END;
/

-- 투기장 페이징 처리 + 조회
CREATE OR REPLACE PROCEDURE USP_GET_PAGE_ARTICLE(
	PI_SEARCH_WORD IN VARCHAR,
	PI_SEARCH_TYPE IN VARCHAR,
	PI_SORT_TYPE IN VARCHAR,
	PI_START IN NUMBER,
	PI_END IN NUMBER,
	PO_CURSOR OUT SYS_REFCURSOR
)
IS
	V_QUERY VARCHAR(1000);
	V_KEYWORD VARCHAR(20) := '%'||PI_SEARCH_WORD||'%'; 
BEGIN	
	V_QUERY:= 'SELECT TB.NO, TB.TITLE, TB.STOCK_CODE, TB.MEMBER_NO, TB.REGDATE, TB.COMPANY_NAME, TB.COUNT_HIT, TB.COUNT_GOOD, TB.COUNT_BAD
		FROM (SELECT A.NO, A.TITLE, A.STOCK_CODE, A.MEMBER_NO, A.REGDATE,
				(SELECT C.COMPANY FROM COMPANY C WHERE C.STOCK_CODE = A.STOCK_CODE) COMPANY_NAME, 
				(SELECT COUNT(*) FROM HIT H WHERE H.BOARD_NO = A.NO AND H.BOARD_TYPE = ''A'') COUNT_HIT,  
				(SELECT COUNT(*) FROM PICK P WHERE P.ARTICLE_NO = A.NO AND OPINION = ''Y'') COUNT_GOOD,
 				(SELECT COUNT(*) FROM PICK P WHERE P.ARTICLE_NO = A.NO AND OPINION = ''N'') COUNT_BAD,
				ROWNUM RNUM
		FROM ARTICLE A ';

 	IF PI_SEARCH_TYPE = 'all' THEN
 			V_QUERY:= V_QUERY || 'JOIN COMPANY C
						ON A.STOCK_CODE = C.STOCK_CODE 
						WHERE C.COMPANY LIKE  '|| ''''||V_KEYWORD||''' 
						OR A.TITLE LIKE '|| ''''||V_KEYWORD||''' ';
		ELSIF PI_SEARCH_TYPE = 'company' THEN
			V_QUERY:= V_QUERY || 'JOIN COMPANY C
						ON A.STOCK_CODE = C.STOCK_CODE 
						WHERE C.COMPANY LIKE '|| ''''||V_KEYWORD||''' ';
		ELSIF PI_SEARCH_TYPE = 'title' THEN
			V_QUERY:= V_QUERY || 'WHERE A.TITLE LIKE '|| ''''||V_KEYWORD||''' ';
	END IF;			
 	
	IF PI_SORT_TYPE = 'latest' THEN
			V_QUERY:= V_QUERY || ' ORDER BY NO DESC) TB ';
 	
		ELSIF PI_SORT_TYPE = 'popularity' THEN
			V_QUERY:= V_QUERY || ' ORDER BY (COUNT_HIT + COUNT_GOOD + COUNT_BAD) DESC) TB ';
	END IF;
	
	V_QUERY:= V_QUERY || ' WHERE RNUM >='|| PI_START ||' AND RNUM <= '|| PI_END;
	
	OPEN PO_CURSOR FOR V_QUERY;
END;
/		

-- 투기장 검색조건에 맞는 전체 게시물 수 계산
CREATE OR REPLACE PROCEDURE USP_TOTAL_COUNT_ARTICLE(
	PI_SEARCH_WORD IN VARCHAR,
	PI_SEARCH_TYPE IN VARCHAR,
	PO_ARTICLE_COUNT OUT NUMBER
)
IS
BEGIN
	IF PI_SEARCH_TYPE = 'all' THEN
		SELECT COUNT(*)
		INTO PO_ARTICLE_COUNT
		FROM ARTICLE A JOIN COMPANY C
		ON A.STOCK_CODE = C.STOCK_CODE
		WHERE C.COMPANY LIKE '%'||PI_SEARCH_WORD||'%'
			OR A.TITLE LIKE '%'||PI_SEARCH_WORD||'%';
	ELSIF PI_SEARCH_TYPE = 'company' THEN
		SELECT COUNT(*)
		INTO PO_ARTICLE_COUNT
		FROM ARTICLE A JOIN COMPANY C
		ON A.STOCK_CODE = C.STOCK_CODE
		WHERE C.COMPANY LIKE '%'||PI_SEARCH_WORD||'%';
	ELSIF PI_SEARCH_TYPE = 'title' THEN
		SELECT COUNT(*)
		INTO PO_ARTICLE_COUNT
		FROM ARTICLE
		WHERE TITLE LIKE '%'||PI_SEARCH_WORD||'%';
	END IF;
END;
/

-- 전월 대비 주가 계산을 위한 전월 주가 조회
CREATE OR REPLACE PROCEDURE USP_PREV_MONTH_STOCK_PRICE(
	PI_STOCK_CODE IN VARCHAR,
	PI_T_DATE IN VARCHAR,
	PO_CLOSE OUT STOCK_RECORDS.CLOSE%TYPE
)
AS
BEGIN
	SELECT TB.CLOSE
	INTO PO_CLOSE
	FROM (SELECT *
			FROM STOCK_RECORDS
			WHERE T_DATE <= TO_CHAR(ADD_MONTHS(PI_T_DATE,-1),'yyyy-mm-dd')
				AND STOCK_CODE = PI_STOCK_CODE
			ORDER BY T_DATE DESC) TB
	WHERE ROWNUM = 1;
END;
/

-- 투기장 선택 조회
CREATE OR REPLACE PROCEDURE USP_GET_ARTICLE(
	PI_NO IN ARTICLE.NO%TYPE,
	PO_TITLE OUT ARTICLE.TITLE%TYPE,
	PO_STOCK_CODE OUT ARTICLE.STOCK_CODE%TYPE,
	PO_MEMBER_NO OUT ARTICLE.MEMBER_NO%TYPE,	
	PO_REGDATE OUT ARTICLE.REGDATE%TYPE,
	PO_COMPANY_NAME OUT COMPANY.COMPANY%TYPE,
	PO_COUNT_HIT OUT NUMBER,
	PO_COUNT_COMMENTS OUT NUMBER,
	PO_COUNT_GOOD OUT NUMBER,
	PO_COUNT_BAD OUT NUMBER
)
AS
BEGIN
	SELECT A.TITLE, A.STOCK_CODE, A.MEMBER_NO, A.REGDATE,
		(SELECT C.COMPANY FROM COMPANY C WHERE C.STOCK_CODE = A.STOCK_CODE) COMPANY_NAME, 
		(SELECT COUNT(*) FROM HIT H WHERE H.BOARD_NO = A.NO AND H.BOARD_TYPE = 'A') COUNT_HIT,
		(SELECT COUNT(*) FROM COMMENTS C WHERE C.ARTICLE_NO = A.NO) COUNT_COMMENTS, 
		(SELECT COUNT(*) FROM PICK P WHERE P.ARTICLE_NO = A.NO AND OPINION = 'Y') COUNT_GOOD,
 		(SELECT COUNT(*) FROM PICK P WHERE P.ARTICLE_NO = A.NO AND OPINION = 'N') COUNT_BAD
	INTO PO_TITLE, PO_STOCK_CODE, PO_MEMBER_NO, PO_REGDATE, PO_COMPANY_NAME, PO_COUNT_HIT, 
		PO_COUNT_COMMENTS, PO_COUNT_GOOD, PO_COUNT_BAD
	FROM ARTICLE A
	WHERE A.NO = PI_NO;
END;
/

-- 회사 가장 최근 분기의 Finance 정보 받아오기
CREATE OR REPLACE PROCEDURE USP_GET_RECENT_FINANCE(
	PI_STOCK_CODE IN FINANCE.STOCK_CODE%TYPE,
	PO_CURSOR OUT SYS_REFCURSOR
)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT F.NO, F.YEAR, F.QUARTER, F.STOCK_CODE, 
			F.ACCOUNT_CODE, F.ACCOUNT_VALUE, F.REGDATE, C.LABEL_KOR 
		FROM FINANCE F JOIN FINANCE_CATE C
		ON F.ACCOUNT_CODE = C.ACCOUNT_ID
		WHERE F.STOCK_CODE = PI_STOCK_CODE
			AND F.YEAR = (SELECT MAX(YEAR)
							FROM FINANCE)
			AND F.QUARTER = (SELECT MAX(QUARTER)
							FROM FINANCE
							WHERE YEAR = (SELECT MAX(YEAR)
											FROM FINANCE));
END;
/

-- 해당 업종의 재무정보들의 평균 구하기
CREATE OR REPLACE PROCEDURE USP_GET_AVERAGE_FINANCE(
	PI_INDUSTRY_NO IN COMPANY.INDUSTRY_NO%TYPE,
	PO_CURSOR OUT SYS_REFCURSOR	
)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT TB.LABEL_KOR, AVG(TB.ACCOUNT_VALUE) AVG_ACCOUNT_VALUE
		FROM (SELECT *
				FROM FINANCE F JOIN FINANCE_CATE FC
				ON F.ACCOUNT_CODE = FC.ACCOUNT_ID) TB JOIN COMPANY C
		ON TB.STOCK_CODE = C.STOCK_CODE
		WHERE C.INDUSTRY_NO = PI_INDUSTRY_NO
			AND TB.YEAR = (SELECT MAX(YEAR)
							FROM FINANCE)
			AND TB.QUARTER = (SELECT MAX(QUARTER)
							FROM FINANCE
							WHERE YEAR = (SELECT MAX(YEAR)
											FROM FINANCE))
		GROUP BY TB.LABEL_KOR;
END;
/

-- 해당 게시판의 각 풀매수, 풀매도 받아오기
CREATE OR REPLACE PROCEDURE GET_COUNT_PICK(
	PI_ARTICLE_NO IN PICK.ARTICLE_NO%TYPE,
	PO_COUNT_GOOD OUT NUMBER,
	PO_COUNT_BAD OUT NUMBER
)
AS
BEGIN
	SELECT (SELECT COUNT(*)
			FROM PICK
			WHERE ARTICLE_NO = PI_ARTICLE_NO
			AND OPINION = 'Y') COUNT_GOOD,
			(SELECT COUNT(*)
			FROM PICK
			WHERE ARTICLE_NO = PI_ARTICLE_NO
			AND OPINION = 'N') COUNT_BAD
	INTO PO_COUNT_GOOD, PO_COUNT_BAD
	FROM DUAL;
END;
/

-- COMMENTS(댓글)과 PICK(매수의견) 함께 인서트하는 프로시져 
-- 잘못 insert된 경우 둘다 함께 rollback
-- 구체적인 인풋값 검증은 controller나 biz단에서 하되 잘못 넘어와도 db형태에 맞지 않으면 롤백
CREATE OR REPLACE PROCEDURE USP_ADD_PICK_AND_COMMENTS(
	PI_MEMBER_NO IN NUMBER,
	PI_ARTICLE_NO IN NUMBER,
	PI_CONTENT COMMENTS.CONTENT%TYPE,
	PI_OPINION PICK.OPINION%TYPE	
)
IS
BEGIN
	INSERT INTO PICK VALUES(PICK_SEQ.NEXTVAL, PI_OPINION, PI_MEMBER_NO,
				PI_ARTICLE_NO, SYSDATE);
	INSERT INTO COMMENTS VALUES(COMMENTS_SEQ.NEXTVAL, PI_MEMBER_NO, PI_ARTICLE_NO,
				PI_CONTENT, PICK_SEQ.CURRVAL, SYSDATE);
EXCEPTION
	WHEN OTHERS THEN
	ROLLBACK;
END;
/

-- 해당 투기장 게시물 번호와 현재 페이지에 해당하는 매수의견과 매도의견을 두개의 커서로 받는 프로시져
CREATE OR REPLACE PROCEDURE USP_GET_PICK_AND_COMMENTS(
	PI_ARTICLE_NO IN NUMBER,
	PI_START IN NUMBER,
	PI_END IN NUMBER,
	PO_GOOD_CURSOR OUT SYS_REFCURSOR,
	PO_BAD_CURSOR OUT SYS_REFCURSOR
)
IS
BEGIN
	OPEN PO_GOOD_CURSOR FOR
		SELECT TB.NO, TB.MEMBER_NO, TB.ARTICLE_NO, TB.CONTENT, TB.OPINION, M.NICKNAME
		FROM (SELECT C.NO, C.MEMBER_NO, C.ARTICLE_NO, C.CONTENT, P.OPINION, ROWNUM RNUM
		 	 FROM COMMENTS C JOIN PICK P
		 	 ON C.PICK_NO = P.NO
			 WHERE C.ARTICLE_NO = PI_ARTICLE_NO
			 	 AND P.OPINION = 'Y'
			 ORDER BY 1 DESC) TB JOIN MEMBER M
		ON TB.MEMBER_NO = M.NO
		WHERE TB.RNUM >= PI_START AND TB.RNUM <= PI_END;
	
	
	OPEN PO_BAD_CURSOR FOR
			SELECT TB.NO, TB.MEMBER_NO, TB.ARTICLE_NO, TB.CONTENT, TB.OPINION, M.NICKNAME
		FROM (SELECT C.NO, C.MEMBER_NO, C.ARTICLE_NO, C.CONTENT, P.OPINION, ROWNUM RNUM
		 	 FROM COMMENTS C JOIN PICK P
		 	 ON C.PICK_NO = P.NO
			 WHERE C.ARTICLE_NO = PI_ARTICLE_NO
			 	 AND P.OPINION = 'N'
			 ORDER BY 1 DESC) TB JOIN MEMBER M
		ON TB.MEMBER_NO = M.NO
		WHERE TB.RNUM >= PI_START AND TB.RNUM <= PI_END;
END;
/

-- 각 comments total count
	CREATE OR REPLACE PROCEDURE USP_TOTAL_COUNT_COMMENTS(
		PI_ARTICLE_NO IN NUMBER,
		PO_GOOD_COUNT OUT NUMBER,
		PO_BAD_COUNT OUT NUMBER
	)
	IS
	BEGIN
		SELECT (SELECT TB.CNT 
				FROM (SELECT P.OPINION , COUNT(*) CNT
						FROM COMMENTS C JOIN PICK P
						ON C.PICK_NO = P.NO
						WHERE C.ARTICLE_NO = PI_ARTICLE_NO
						GROUP BY P.OPINION) TB
					WHERE TB.OPINION = 'Y') GOOD_COUNT,
				(SELECT TB.CNT 
				FROM (SELECT P.OPINION , COUNT(*) CNT
						FROM COMMENTS C JOIN PICK P
						ON C.PICK_NO = P.NO
						WHERE C.ARTICLE_NO = PI_ARTICLE_NO
						GROUP BY P.OPINION) TB
					WHERE TB.OPINION = 'N') BAD_COUNT
	INTO PO_GOOD_COUNT, PO_BAD_COUNT
	FROM DUAL;
	END;
	/

-- 해당 회사의 가장 최근 열린 투기장과 댓글 n개 불러오기;
CREATE OR REPLACE PROCEDURE USP_GET_RECENT_COMMENTS(
	PI_STOCK_CODE IN VARCHAR,
	PI_NUM IN NUMBER,
	PO_CURSOR OUT SYS_REFCURSOR
)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT C.NO, C.MEMBER_NO, C.ARTICLE_NO, C.CONTENT, C.REGDATE, P.OPINION
			FROM COMMENTS C JOIN PICK P
			ON C.PICK_NO = P.NO
			WHERE C.ARTICLE_NO = (SELECT TB.NO
		      					FROM (SELECT NO, ROWNUM RNUM
										FROM ARTICLE
										WHERE STOCK_CODE = PI_STOCK_CODE
										ORDER BY NO DESC) TB
		    					WHERE RNUM <= PI_NUM )
		   	ORDER BY C.NO DESC;
END;
/

-- 해당 투기장 게시물 번호와 현재 페이지에 해당하는 매수의견과 매도의견을 하나의 커서로 받는 프로시져
CREATE OR REPLACE PROCEDURE USP_GET_PICK_AND_COMMENTS(
	PI_ARTICLE_NO IN NUMBER,
	PI_START IN NUMBER,
	PI_END IN NUMBER,
	PO_CURSOR OUT SYS_REFCURSOR
)
IS
BEGIN
	OPEN PO_CURSOR FOR
		SELECT TB.NO, TB.MEMBER_NO, TB.ARTICLE_NO, TB.CONTENT, TB.REGDATE, TB.OPINION, M.NICKNAME
		FROM (SELECT C.NO, C.MEMBER_NO, C.ARTICLE_NO, C.CONTENT, C.REGDATE, P.OPINION, ROWNUM RNUM
		 	 FROM COMMENTS C JOIN PICK P
		 	 ON C.PICK_NO = P.NO
			 WHERE C.ARTICLE_NO = PI_ARTICLE_NO
			 ORDER BY 1 DESC) TB JOIN MEMBER M
		ON TB.MEMBER_NO = M.NO
		WHERE TB.RNUM >= PI_START AND TB.RNUM <= PI_END
		ORDER BY 1 DESC;
END;
/